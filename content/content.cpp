// Content generator
// usage: content file.cpp [files.cpp]
// Oleg Mazonka 2009

/** Content  (autogenerated by http://mazonka.com/subleq/content.cpp)
 
  1 Standard headers   .....................................   (30-38:8)
  2 Section class definition   .............................   (39-60:21)
  3 Forward declarations   .................................   (61-65:4)
  4 Function definitions   .................................   (66-365)
    4.1 Main   .............................................   (67-124:57)
    4.2 Utility   ..........................................   (125-133:8)
    4.3 Section implementation   ...........................   (134-234)
      4.3.1 depth   ........................................   (135-141:6)
      4.3.2 add   ..........................................   (142-148:6)
      4.3.3 recursive line initialization   ................   (149-163:14)
      4.3.4 recursive counter   ............................   (164-175:11)
      4.3.5 recursive printing content   ...................   (176-205:29)
      4.3.6 recursive printing body   ......................   (206-225:19)
      4.3.7 getting grand parent   .........................   (226-234:8)
    4.4 Functions implementation   .........................   (235-365)
      4.4.1 Consume header   ...............................   (237-249:12)
      4.4.2 Consume conetnt   ..............................   (250-263:13)
      4.4.3 Consume section   ..............................   (264-365)
        4.4.3.1 Read in section   ..........................   (265-285:20)
        4.4.3.2 Calculate sector depth   ...................   (286-295:9)
        4.4.3.3 Extract section header   ...................   (296-313:17)
        4.4.3.4 Consume section main function   ............   (314-365:51)
**/

/** 1 Standard headers **/
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
using namespace std;

/** 2 Section class definition **/
struct section
{
	section * parent;
	vector<section*> kids;
	string body, sector, header;

	int start, size, end;

	section(section *p): parent(p), start(0), size(0) {}
	section(string b, string s, string h, int sz): 
		parent(0), body(b), sector(s), header(h), start(0), size(sz) {}
	int getDepth();
	void add(section * p);
	string print(string newsector);
	string printfull(string newsector);
	section * getGrand(int depth);
	int lines(int offset);
	int getsize() const { return end-start; }
	int counter() const;
};

/** 3 Forward declarations **/
string getHeader(vector<string> & v, int *index);
string getContent(vector<string> & v, int *index);
bool getSection(vector<string> & v, int *index, section * parent);

/** 4 Function definitions **/
/** 4.1 Main **/
int main(int ac, char *av[])
{
  try{
	if( ac < 2 )
	{
		cout<<"Usage: content file.cpp [other filenames]\n";
		return 0;
	}

	vector<string> file;
	for( int i=1; i<ac; i++ )
	{
		ifstream in(av[i]);
		if( !in )
		{
			cout<<"cannot open "<<av[1]<<'\n';
			return 1;
		}
		while(1)
		{
			string s;
			getline(in,s);
			if( !in ) break;
			file.push_back(s);
		}
	}

	int index=0;
	string header = getHeader(file,&index);
	int header_size = index;
	string content= getContent(file,&index);
	
	section root(0);
	while( getSection(file,&index,&root) ) ;

	root.lines(header_size+root.counter()+3);

	{
		ofstream of(av[1]);
		if( !of )
			throw string()+"Cannot open file for writing: "+av[1];
	
		of<<header;
		of<<"/** Content";
		of<<"  (autogenerated by http://mazonka.com/subleq/content.cpp)\n";
		of<<root.print("");
		of<<"**/\n\n";
		of<<root.printfull("");
	}

  } catch( string err )
  {
	cerr<<err<<'\n';
	return 2;
  }
}

/** 4.2 Utility **/
string i2a(int x)
{
        std::ostringstream os;
        os<<x;
        return os.str();
}


/** 4.3 Section implementation **/
/** 4.3.1 depth **/
int section::getDepth()
{
	if( parent==0 ) return 0;
	return 1+parent->getDepth();
}

/** 4.3.2 add **/
void section::add(section * p)
{
	kids.push_back(p);
	p->parent = this;
}

/** 4.3.3 recursive line initialization **/
int section::lines(int offset)
{
	start = offset;
	offset += size;

	for( int i=0; i<kids.size(); i++ )
	{
		offset += kids[i]->lines(offset);
	}

	end = offset;
	return end-start;
}

/** 4.3.4 recursive counter **/
int section::counter() const
{
	int sum = 1;

	for( int i=0; i<kids.size(); i++ )
	{
		sum += kids[i]->counter();
	}
	return sum;
}

/** 4.3.5 recursive printing content **/
string section::print(string newsector)
{
	string r;
	int depth = getDepth();
	for( int i=0; i<depth; i++ ) r += "  ";

	r += newsector + ' '+ header;
	if( depth ) 
	{
		r += "   ";
		int pad = 60 - int(r.size());
		for( int i=0; i<pad; i++ ) r += ".";
		r += "   (" + i2a(start)+ "-" + i2a(end-1);
		if( kids.empty() ) r += ":"+i2a(end-1-start);
		r += ")";
	}
	r += '\n';

	for( int i=0; i<kids.size(); i++ )
	{
		string s(newsector);
		if( s!= "" ) s+=".";
		s += i2a(i+1);
		r += kids[i]->print(s);
	}

	return r;
}

/** 4.3.6 recursive printing body **/
string section::printfull(string newsector)
{
	string r;

	if( header!="" ) r += "/** "+newsector + ' '+ header+ " **/\n";
	r += body;

	for( int i=0; i<kids.size(); i++ )
	{
		string s(newsector);
		if( s!= "" ) s+=".";
		s += i2a(i+1);
		r += kids[i]->printfull(s);
	}

	return r;
}


/** 4.3.7 getting grand parent **/
section * section::getGrand(int depth)
{
	int mydepth = getDepth();
	if( depth==mydepth ) return this;
	if( parent ) return parent->getGrand(depth);
	return 0;
}

/** 4.4 Functions implementation **/

/** 4.4.1 Consume header **/
string getHeader(vector<string> & v, int *index)
{
	int & i = * index;
	string r;
	for( ;i<v.size(); i++ )
	{
		if( v[i].substr(0,11) == "/** Content" ) break;
		r += v[i] + '\n';
	}
	return r;
}

/** 4.4.2 Consume conetnt **/
string getContent(vector<string> & v, int *index)
{
	int & i = * index;
	string r;
	for( ;i<v.size(); i++ )
	{
		r += v[i] + '\n';
		if( v[i].substr(0,3) == "**/" ) break;
	}
	i++;
	return r;
}

/** 4.4.3 Consume section **/
/** 4.4.3.1 Read in section **/
string readSection(vector<string> & v, int *index)
{
	int & i = * index;
	string r;
	for( ;i<v.size(); i++ )
		if( v[i].substr(0,3) == "/**" ) break;

	if( i==v.size() ) return r;
	r += v[i++] + '\n';
	if( i==v.size() ) return r;

	for( ;i<v.size(); i++ )
	{
		if( v[i].substr(0,3) == "/**" ) break;
		r += v[i] + '\n';
	}

	return r;
}

/** 4.4.3.2 Calculate sector depth **/
int getDepth(const string &s)
{
	int r=0;
	for( int i=0; i<s.size(); i++ )
	if( s[i]=='.' ) r++;
	return r;
}


/** 4.4.3.3 Extract section header **/
string extractSectionHeader(string &body, string sector)
{
	string::size_type i = body.find(sector);
	if( i==string::npos ) throw "Cannot find sector '"+sector+"': "+body;
	string::size_type j = body.find("**/",i);
	if( j==string::npos ) throw "Cannot find ending '**/': "+body;

	string::size_type k = i+sector.size();
	string r = body.substr( k, j-k );
	while( r.size() && r[0] == ' ') r = r.erase(0,1);
	while( r.size() && r[r.size()-1] == ' ') r = r.erase(r.size()-1);

	body = body.substr(j+4);

	return r;
}

/** 4.4.3.4 Consume section main function **/
bool getSection(vector<string> & v, int *index, section * parent)
{
	int size = *index;
	string body = readSection(v,index);
	size = *index - size;

	if( body == "" ) return false;

	istringstream is(body);
	string sector;
	is>>sector>>sector;
	string header = extractSectionHeader(body,sector);

	int sector_depth = getDepth(sector);
	int section_depth = parent->getDepth();

	cout<<sector<<"("<<sector_depth<<") '"<<header<<"'\n";
	section * psection = new section(body,sector,header,size);

	if( sector_depth == section_depth+1 )
	{
		if( parent->kids.empty() )
			throw "Cannot add (no kids): "+header;

		parent->kids.back()->add(psection);
		return getSection(v,index,parent->kids.back());
	}

	if( sector_depth > section_depth )
	{
		cout<<"Section depth ("<<section_depth<<")\n";
		throw "Cannot add (section depth): "+header;
	}

	if( sector_depth <= section_depth )
	{
		section * grandpa = parent->getGrand(sector_depth);
		if( !grandpa ) 
			throw "Error in: "+header;
		grandpa->add(psection);
		return getSection(v,index,grandpa);
	}

	cout<<sector<<' '<<sector_depth<<' '<<section_depth;
	throw string()+"Internal error";

	return true;
}



